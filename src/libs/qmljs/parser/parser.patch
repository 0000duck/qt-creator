diff --git a/src/libs/qmljs/parser/qmljsengine_p.cpp b/src/libs/qmljs/parser/qmljsengine_p.cpp
index 73850bb..d7d2189 100644
--- a/src/libs/qmljs/parser/qmljsengine_p.cpp
+++ b/src/libs/qmljs/parser/qmljsengine_p.cpp
@@ -110,7 +110,7 @@ double integerFromString(const QString &str, int radix)
 
 
 Engine::Engine()
-    : _lexer(0)
+    : _lexer(0), directives(0)
 { }
 
 Engine::~Engine()
@@ -131,6 +131,12 @@ Lexer *Engine::lexer() const
 void Engine::setLexer(Lexer *lexer)
 { _lexer = lexer; }
 
+void Engine::setDirectives(Directives *directives)
+{ _directives = directives; }
+
+Directives *Engine::directives() const
+{ return _directives; }
+
 MemoryPool *Engine::pool()
 { return &_pool; }
 
diff --git a/src/libs/qmljs/parser/qmljsengine_p.h b/src/libs/qmljs/parser/qmljsengine_p.h
index d4ed4b37..4908e02 100644
--- a/src/libs/qmljs/parser/qmljsengine_p.h
+++ b/src/libs/qmljs/parser/qmljsengine_p.h
@@ -53,6 +53,7 @@ QT_QML_BEGIN_NAMESPACE
 namespace QmlJS {
 
 class Lexer;
+class Directives;
 class MemoryPool;
 
 class QML_PARSER_EXPORT DiagnosticMessage
@@ -80,6 +81,7 @@ public:
 class QML_PARSER_EXPORT Engine
 {
     Lexer *_lexer;
+    Directives *_directives;
     MemoryPool _pool;
     QList<AST::SourceLocation> _comments;
     QString _extraCode;
@@ -97,6 +99,9 @@ public:
     Lexer *lexer() const;
     void setLexer(Lexer *lexer);
 
+    void setDirectives(Directives *directives);
+    Directives *directives() const;
+
     MemoryPool *pool();
 
     inline QStringRef midRef(int position, int size) { return _code.midRef(position, size); }
diff --git a/src/libs/qmljs/parser/qmljsparser.cpp b/src/libs/qmljs/parser/qmljsparser.cpp
index d53960b..71e994f 100644
--- a/src/libs/qmljs/parser/qmljsparser.cpp
+++ b/src/libs/qmljs/parser/qmljsparser.cpp
@@ -143,7 +143,20 @@ bool Parser::parse(int startToken)
 
     token_buffer[0].token = startToken;
     first_token = &token_buffer[0];
-    last_token = &token_buffer[1];
+    if (startToken == T_FEED_JS_PROGRAM) {
+        Directives ignoreDirectives;
+        Directives *directives = driver->directives();
+        if (!directives)
+            directives = &ignoreDirectives;
+        lexer->scanDirectives(directives);
+        token_buffer[1].token = lexer->tokenKind();
+        token_buffer[1].dval = lexer->tokenValue();
+        token_buffer[1].loc = location(lexer);
+        token_buffer[1].spell = lexer->tokenSpell();
+        last_token = &token_buffer[2];
+    } else {
+        last_token = &token_buffer[1];
+    }
 
     tos = -1;
     program = 0;
